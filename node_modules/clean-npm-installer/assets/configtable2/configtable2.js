(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.configtable = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.duplicates = duplicates;
function duplicates(collection, fields) {
	var seens = new Map(),
	    signature = function signature(m, fields) {
		return fields.map(function (f) {
			return m.get(f);
		}).join('-');
	};

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = collection.models[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var model = _step.value;

			var sig = signature(model, fields),
			    seen = seens.get(sig);

			if (seen) {
				seen.push(model);
			} else {
				seens.set(sig, [model]);
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var duplicates = [];
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = seens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var _step2$value = _slicedToArray(_step2.value, 2);

			var key = _step2$value[0];
			var value = _step2$value[1];

			if (value.length > 1) {
				duplicates.push(value);
			}
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	return duplicates;
}

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.VERSION = exports.ConfigTable = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.init = init;
exports.get = get;

var _draggable = require('./draggable');

var _draggable2 = _interopRequireDefault(_draggable);

var _entryviewmanager = require('./entryviewmanager');

var _entryviewmanager2 = _interopRequireDefault(_entryviewmanager);

var _constraintmanager = require('./constraintmanager');

var _constraintmanager2 = _interopRequireDefault(_constraintmanager);

var _sortmethods = require('./sortmethods');

var _sortmethods2 = _interopRequireDefault(_sortmethods);

var _stickyfloat = require('./stickyfloat');

var _stickyfloat2 = _interopRequireDefault(_stickyfloat);

var _templateBuilder = require('./template-builder');

var _templateBuilder2 = _interopRequireDefault(_templateBuilder);

var _diff = require('./diff');

var _diff2 = _interopRequireDefault(_diff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_stickyfloat2.default.enable();

var ConfigTableDataName = 'configtable',
    defaultLoadingTemplate = _.template(''); /*_.template(
                                             '<div class="loading"></span>Loading... <%= progress %>%<span class="bar" style="width: <%= progress %>%"></div>'
                                             );*/

var _registry = new Set(),
    _listening = false;

function update() {
	var dim = {
		windowY: $(window).scrollTop(),
		windowH: $(window).innerHeight()
	};

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = _registry[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var ct = _step.value;

			ct.updateViewableArea(dim);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}
}

function enable() {
	if (!_listening) {
		_listening = true;
		$(window).on('scroll.configtable resize.configtable', update).on('click.configtable', focusCheck);
	}
}

function disable() {
	$(window).off('.configtable');
	_listening = false;
}

function register(configtable) {
	_registry.add(configtable);
	if (!_listening) {
		enable();
	}
}

function unregister(configtable) {
	_registry.delete(configtable);
	if (_registry.length === 0) {
		disable();
	}
}

function focusCheck(event) {
	var $el = $(event.target).closest('.configtable'),
	    match = $el.data('configtable');

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = _registry[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var ct = _step2.value;

			if (match !== ct) {
				ct.focusEntry(null);
			}
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}
}

var ConfigTable = exports.ConfigTable = function () {
	_createClass(ConfigTable, null, [{
		key: 'checkOptions',
		value: function checkOptions(options) {
			var required = ['element', 'dataProvider'];

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = required[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var prop = _step3.value;

					if (typeof options[prop] === 'undefined') {
						throw new Error(prop + ' option required');
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}
	}]);

	function ConfigTable(options) {
		var _this = this;

		_classCallCheck(this, ConfigTable);

		ConfigTable.checkOptions(options);

		// option: state
		this.state = options.state || new Backbone.Model({
			modified: false
		});

		// option: eventPrefix
		this.eventPrefix = options.eventPrefix || 'configtable';

		// option: gridCount
		this.gridCount = options.gridCount || 20;

		// option: element (css selector or dom element to use as root element)
		this.$el = options.element = $(options.element);
		this.$el.addClass('configtable');

		this.validation = options.validation;

		this.constrain = options.constrain || {};

		// option: model (or defaults)
		// This option is used to specify default values for new entries. You can
		// either provide a Backbone.Model class, or if an object is passed in, it
		// will be used to construct a new generic Backbone.Model with `defaults` set
		// to the passed-in object. Note that if the model needs to be altered at
		// instantiation, the `modelInit` option may be used (below).
		options.model = options.model || options.defaults;
		if (options.model) {
			if (options.model instanceof Backbone.Model) {
				this.Model = options.model;
			} else {
				this.Model = Backbone.Model.extend({
					defaults: options.model
				});
			}
		} else {
			this.Model = Backbone.Model;
		}

		// option: modelInit called during the "append" action, this function can
		// be overridden in order to provide the newly inserted entry with default
		// properties. Index is provided if the model is being appended after another
		// entry.
		this.modelInit = function (index) {
			return new _this.Model();
		};

		// option: entryInit called within the context of the row, includes
		// the row element and model associated with row. This is called
		// when an element comes into view.
		//
		// It is advised not to alter the DOM if at all possible. Rather
		// than using jQuery's .on() for event interaction, you should use
		// Backbone's this.listenTo() since those are automatically unbound
		// after the row's DOM is reallocated. If you do alter DOM, realize
		// that the DOM will be reused, so be prepared to clean-up alterations
		// upon element reuse.
		//
		// Also try to avoid reading values from the DOM. Data bound via
		// data-ct-bind should be reflected within the passed in model and
		// pre-sanitized.
		this.entryInit = function (item, model) {
			if (options.entryInit) {
				options.entryInit.apply(item, [_this, model]);
			}
		};

		// An element's height can be overridden, but in most cases the automatic
		// measurement should be sufficient.
		this.forceEntryHeight = options.forceEntryHeight;

		// Allow re-ordering via drag-and-drop (this implies `showPosition`)
		this.dragAndDrop = options.dragAndDrop || false;

		// Show row numbers along the left side
		this.showPosition = this.dragAndDrop || options.showPosition || false;

		// Enable stickyfloat for header and footer.
		// If a string is provided, it will be used to denote which stickyfloat
		// group the header and footer will become a part of.
		this.stickyFloat = options.stickyFloat || false;

		// Grid size should be set directly via CSS.
		if (options.gridCount) {
			console.log('Deprecated: configtable: specify grid-<n> in css rather than passing `gridCount`');
			this.$el.addClass('grid-' + options.gridCount);
		}

		// This should return the horizontal top line of the *entry container*
		// element on the page. **THIS WILL BE BELOW THE HEADER**
		this.getEntryContainerHorizontalOffset = _.throttle(function () {
			return Math.round(_this.container.$entry.offset().top);
		}, 0);

		// initialization
		this.viewable = { min: -1, max: -1 };

		// Permit loading indicator usage
		this.isLoading = true;

		// Store active validation issues within a Map
		// Keys should correspond to model cid.
		this.invalidations = new Map();

		// Models that have had modifications made dirty and should be redrawn ASAP
		//this.redraw = new Set();

		// Store field names (per-model) that have been
		// modified by the user.
		this.modifications = new Map();

		this.start = function () {

			// Begin initialization
			var initCompleted = false,
			    dataCompleted = false,
			    complete = function complete() {
				if (initCompleted && dataCompleted) {
					(function () {
						var postInit = function postInit() {
							if (typeof options.onReady === 'function') {
								options.onReady.apply(_this);
							}
							_this.postInit();
						};

						// If the element is currently not visible, then measurements
						// will fail horribly and nothing will work. This way we
						// postpone rendering until visible.
						if (_this.$el.is(':visible')) {
							postInit();
						} else {
							(function () {
								var interval = setInterval(function () {
									if (_this.$el.is(':visible')) {
										postInit();
										clearInterval(interval);
									}
								}, 200);
							})();
						}
					})();
				}
				// otherwise we wait...
			};

			_this.initializeDataProviderAsync(options.dataProvider, function (collection) {
				_this.isLoading = false;

				if (!(collection instanceof Backbone.Collection)) {
					collection = new Backbone.Collection(collection);
				}

				_this.collection = collection;

				if (_this.constrain) {
					_this.constraintManager = new _constraintmanager2.default(collection, _this.constrain, {
						getIndex: function getIndex(model) {
							return _this.getOriginalModelIndex(model);
						}
					});
				}

				_this.addDataListeners();

				_this.entryViewManager = new _entryviewmanager2.default({
					buildEntry: function buildEntry(model) {
						return _this.templates.entry(model, {
							showPosition: _this.showPosition
						});
					},
					getIndex: function getIndex(model) {
						return _this.getOriginalModelIndex(model);
					},
					getEntryParentElement: function getEntryParentElement() {
						return _this.container.$entries;
					},
					getCollection: function getCollection() {
						return _this.collection;
					},
					getModelAt: function getModelAt(row) {
						return _this.getModelAt(row);
					},
					getEntryInit: function getEntryInit() {
						return _this.entryInit;
					}
				});

				_this.dimensions = {
					viewYMin: 0
				};

				dataCompleted = true;

				// Fork initial async validation processing
				_this.validate(function () {}, false);

				complete();
			});

			_this.initializeSubsystemsAsync(options, function () {
				initCompleted = true;
				complete();
			});
		};

		if (options.autoStart !== false) {
			this.start();
		}
	}

	// Subsystem initialization must not rely on the dataProvider!


	_createClass(ConfigTable, [{
		key: 'initializeSubsystemsAsync',
		value: function initializeSubsystemsAsync(options, done) {
			// Attach this instance to the DOM element using $.data
			if (typeof this.$el.data(ConfigTableDataName) !== 'undefined') {
				this.$el.data(ConfigTableDataName).destroy();
				//throw new Error('attempted to recreate configtable on existing element');
			}
			this.$el.data(ConfigTableDataName, this);

			// Initialize templates
			this.parseTemplates(options);

			// Prepare element containers, this includes some DOM manipulation
			this.prepareElementContainers();

			// Construct instances of the header and footer templates
			// and attach them to the appropriate elements.
			this.setHeaderAndFooter();

			// Add delegated event handlers for the various containers
			this.addDOMListeners();

			// Initialize JQueryUI tooltips for error display if available
			// (this should probably be split out and handled elsewhere)
			if ($.fn.tooltip) {
				$(this.container.$entry).tooltip({
					position: {
						my: 'bottom',
						at: 'top-2',
						collision: 'flipfit'
					},
					items: '.ui-state-error:enabled',
					content: function content() {
						return $(this).attr('validation-msg');
					}
				});
			}

			// Call async callback to indicate that subsystems are initialized
			done();
		}

		// If `provider` is a function that accepts an argument it will be
		// treated as asynchronous. The first argument passed will be the
		// completion callback function. You must call it with the collection.

	}, {
		key: 'initializeDataProviderAsync',
		value: function initializeDataProviderAsync(provider, done) {
			var _this2 = this;

			var result;

			if (typeof provider === 'function') {
				result = provider(function (data) {
					return done(data);
				}, function (progress) {
					return _this2.loading(progress);
				});
				// If provider returns a value then we use that
				// to satisfy the async callback, otherwise we
				// assume it's working and wait for the callback.
				if (result) {
					done(result);
				}
			} else {
				done(provider);
			}
		}
	}, {
		key: 'postInit',
		value: function postInit() {
			register(this);
			this.resize();
			this.render();
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			unregister(this);
			this.container.$header.remove();
			this.container.$entry.remove();
			this.container.$footer.remove();
		}
	}, {
		key: 'parseTemplates',
		value: function parseTemplates(options) {
			var _this3 = this;

			var templates = {},
			    $templates = this.$el.find('script[type="text/template"]'),
			    getInvalidation = function getInvalidation(cid) {
				return _this3.invalidations.get(cid);
			},
			    getModification = function getModification(cid) {
				return _this3.modifications.get(cid);
			};

			// Scan for all templates
			for (var i = 0; i < $templates.length; i++) {
				var $e = $($templates[i]),
				    name = $e.attr('name'),
				    template = $e.text().trim().replace(/^(\s+)/gm, '').replace(/(\r\n|\n|\r)/gm, ' ').trim();

				templates[name] = (0, _templateBuilder2.default)(template, {
					name: name,
					showPosition: this.showPosition,
					invalidation: getInvalidation,
					modification: getModification,
					hasFocus: function hasFocus(cid) {
						return cid === _this3.currentFocusedModelCid;
					},
					entryHeight: function entryHeight() {
						return _this3.dimensions.rowH;
					}
				});
			}

			return this.templates = templates;
		}
	}, {
		key: 'prepareElementContainers',
		value: function prepareElementContainers() {
			this.container = {
				$header: $('<div class="ct-header-container"></div>'),
				$entry: $('<div class="ct-entry-container"><div class="ct-entries"></div></div>'),
				$footer: $('<div class="ct-footer-container"></div>')
			};

			this.container.$entries = this.container.$entry.find('.ct-entries');

			this.$el.append([this.container.$header, this.container.$entry, this.container.$footer]);

			this.$el.toggleClass('show-numbers', this.showPosition);
		}
	}, {
		key: 'addDataListeners',
		value: function addDataListeners() {
			var _this4 = this;

			this.listenTo(this.collection, 'remove', function (model) {
				_this4.propagateToOriginalOrder('remove', model, _this4.collection);
				_this4.validateRelatedModels(model, true);
				_this4.invalidations.delete(model.cid);
				_this4.updateValidationStateClasses();
				_this4.entryViewManager.reset();
				_this4.resize();
				update();
			});

			this.listenTo(this.collection, 'add', function (model) {
				_this4.propagateToOriginalOrder('add', model, _this4.collection);
				_this4.entryViewManager.reset();
				_this4.resize();
				update();
			});

			this.listenTo(this.collection, 'sort', function (e) {
				_this4.applyConstraints(true);
				_this4.entryViewManager.reset();
				update();
			});

			this.listenTo(this.collection, 'reset', function (e) {
				_this4.entryViewManager.reset();
				update();
			});

			this.listenTo(this.collection, 'change', function (model) {
				_this4.validateRelatedModels(model, _.keys(model.changed));
				_this4.validateModel(model);
				_this4.storeModelModifications(model);
				_this4.state.set('modified', true);
			});

			this.listenTo(this.collection, 'invalid', function (model) {
				console.log('got invalid event', model);
			});

			// proxy state events
			this.listenTo(this.state, 'all', function (event) {
				return _this4.trigger(event);
			});
		}
	}, {
		key: 'validateRelatedModels',
		value: function validateRelatedModels(model, fields, silent) {
			if (this.constraintManager && (this.constraintManager.pending || fields === true)) {
				fields = fields === true ? undefined : fields;

				// slightly confusing, but we collect related models before the
				// constraint sets are updated, as well as afterwards, then the
				// two sets of models are merged and revalidated.
				var related = void 0;

				related = this.constraintManager.modelsRelatedTo(model, fields);
				this.constraintManager.execute();
				related = new Set([].concat(_toConsumableArray(related), _toConsumableArray(this.constraintManager.modelsRelatedTo(model, fields))));

				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = related[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						model = _step4.value;

						this.validateModel(model);
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				return related;
			}
			return new Set(); // no constraint manager, no results.
		}
	}, {
		key: 'setHeaderAndFooter',
		value: function setHeaderAndFooter() {
			this.container.$header.html(this.templates.header(this.model).$el);
			this.container.$footer.html(this.templates.footer(this.model).$el);
		}
	}, {
		key: 'addDOMListeners',
		value: function addDOMListeners() {
			var _this5 = this;

			this.$el.on('click', ':ct2-sortby', function (e) {
				return _this5.onSortCollection(e);
			});

			this.$el.on('click', ':ct2-action', function (e) {
				return _this5.onPerformAction(e);
			});

			this.container.$entry.on('click focus', 'div.ct-entry', function (e) {
				var $entry = $(e.target).closest('.ct-entry');
				_this5.focusEntry($entry);
			});
		}
	}, {
		key: 'loading',
		value: function loading(params) {
			if (this.isLoading) {
				var tmpl = this.state.get('template_loading') || defaultLoadingTemplate;
				this.container.$entries.html(tmpl(params));
			}
		}
	}, {
		key: 'onPerformAction',
		value: function onPerformAction(event) {
			var $el = $(event.target).is(':ct2-action') ? $(event.target) : $(event.target).closest(':ct2-action'),
			    $entry = $el.closest('.ct-entry'),
			    action = $el.attr('data-ct-action');

			return this.performAction(action, $entry);
		}
	}, {
		key: 'performAction',
		value: function performAction(action, $entry) {
			if (typeof this.actions[action] === 'function') {
				return this.actions[action].apply(this, [$entry && $entry.length && $entry]);
			}
			throw Error('Action: "' + action + '" is unknown');
		}

		// Set focus specified by passed-in entry DOM element.
		// See `focusModel()` for setting focus based by model.

	}, {
		key: 'focusEntry',
		value: function focusEntry($entry) {
			this.focusModel($entry ? this.getModelForEntry($entry) : null);
		}

		// Same as `focusEntry()` but allows the use of a model instead

	}, {
		key: 'focusModel',
		value: function focusModel(model) {
			if (this.currentFocusedModelCid) {
				// Remove focus from all visible entries
				this.container.$entry.find('.ct-entry').removeClass('ct-focus');

				// Validate the model that's being blurred
				if (!model || this.currentFocusedModelCid !== model.cid) {
					var blurModel = this.collection.get(this.currentFocusedModelCid);

					if (blurModel) {
						this.validateModel(blurModel);
					}
				}
			}

			this.currentFocusedModelCid = model && model.cid || null;

			if (this.currentFocusedModelCid) {
				var $entry = this.getEntryForModel(model);
				if ($entry) {
					$entry.addClass('ct-focus');
				}
			}
		}
	}, {
		key: 'getModelForEntry',
		value: function getModelForEntry($entry) {
			return this.collection.get($entry.attr('data-model-cid'));
		}
	}, {
		key: 'getEntryForModel',
		value: function getEntryForModel(model) {
			// Note that this will fail if the entry is not currently within the visible area
			var entry = this.container && this.container.$entry.find('[data-model-cid="' + model.cid + '"]');
			return entry && entry.length && entry || undefined;
		}
	}, {
		key: 'storeModelModifications',
		value: function storeModelModifications(model) {
			var record = this.modifications.get(model.cid) || new Set();
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = _.keys(model.changed)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var key = _step5.value;

					record.add(key);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			this.modifications.set(model.cid, record);

			// Update the entry if it's currently visible
			var entry = this.getEntryForModel(model);
			if (entry) {
				entry.data('ct-template').applyModificationStates(record);
			}
		}
	}, {
		key: 'scrollTo',
		value: function scrollTo(param, done) {
			var model, row;

			done = done || function () {};

			if (typeof param === 'number') {
				// Get the model at the requested row (in the original order)
				// and then use the view position as the destination for scrolling to.
				var models = this._original_collection_order || this.collection.models;
				model = models[param - 1];
				if (model) {
					row = this.collection.indexOf(model);
				} else {
					row = param; // just fall back to using the passed row as the row
				}
			} else if (param instanceof Backbone.Model) {
					model = param;
					row = this.collection.indexOf(model);
				} else {
					model = this.collection.findWhere(param);
					row = this.collection.indexOf(model);
				}

			row = Math.min(row, this.collection.length - 1);

			var dim = this.dimensions,
			    entriesTop = this.getEntryContainerHorizontalOffset(),
			    offset = Math.max(0, row * dim.rowH + entriesTop - (dim.viewYSpan * 0.5 - dim.rowH * 0.5));

			// Use jQuery scrollTo plugin if it's available
			if ($.scrollTo) {
				$.scrollTo(offset + 'px', {
					duration: 500,
					onAfter: done
				});
			} else {
				$(window).scrollTop(offset);
				_.defer(done); // Allow a cycle to set up the DOM elements during a far scroll
			}
		}
	}, {
		key: 'onSortCollection',
		value: function onSortCollection(event) {
			var $el = $(event.target);
			$el = $el.is(':ct2-sortby') ? $el : $el.closest(':ct2-sortby');

			try {
				var _$el$attr$match = $el.attr('class').match(/ct-sortby-(_?\w+)-(\w+)/);

				var _$el$attr$match2 = _slicedToArray(_$el$attr$match, 3);

				var cls = _$el$attr$match2[0];
				var attr = _$el$attr$match2[1];
				var method = _$el$attr$match2[2];

				this.sortCollection(attr, method, $el);
			} catch (e) {
				console.log('failed to sort collection');
			}
		}

		// if $el is 'asc' or 'desc' it will be used as the desired sorting direction

	}, {
		key: 'sortCollection',
		value: function sortCollection(attr, method, $el, direction) {
			var _this6 = this;

			var $header = this.container.$header;

			if (!$el) {
				$el = $header.find('.sort-asc, .sort-desc');
			}

			if (!direction) {
				// Obtain the desired sorting direction from the sort element
				direction = $el.hasClass('sort-desc') ? 'asc' : 'desc';
			}

			// If the attribute is _row then we need to switch to the originally sorted
			// model order. But if models were inserted while in another sorting mode, then
			// the original array of models won't contain that model, so we have to do
			// a little shuffling around and merge the sorted list back into the original.

			if (attr === '_row') {
				if (typeof this._original_collection_order !== 'undefined') {
					(function () {
						var order = _this6._original_collection_order;
						_this6.collection.comparator = function (a, b) {
							var ai = order.indexOf(a),
							    bi = order.indexOf(b);

							return ai < 0 || bi < 0 ? 0 : ai - bi;
						};
						_this6.collection.sort();
						_this6.collection.comparator = undefined;
						delete _this6._original_collection_order;
					})();
				}

				if (direction === 'asc') {
					this._original_collection_order = this.collection.models.slice();
					this.collection.models.reverse();
					this.collection.trigger('sort');
				}
			} else {
				if (typeof this._original_collection_order === 'undefined') {
					this._original_collection_order = this.collection.models.slice();
				}

				this.collection.comparator = direction === 'desc' ? function (a, b) {
					return _sortmethods2.default[method](a.get(attr), b.get(attr));
				} : function (a, b) {
					return _sortmethods2.default[method](b.get(attr), a.get(attr));
				};
				this.collection.sort();
				this.collection.comparator = undefined;
			}

			// Only enable drag and drop while we're in the default sort order
			this.setDnD(this.dragAndDrop && typeof this._original_collection_order === 'undefined');

			// Update header DOM to reflect new sorting method in action
			$header.find('.sort-asc, .sort-desc').removeClass('sort-asc').removeClass('sort-desc');

			// Update the appropriate sorting column
			$header.find('.ct-sortby-' + attr + '-' + method).addClass('sort-' + direction);

			return false;
		}
	}, {
		key: 'propagateToOriginalOrder',
		value: function propagateToOriginalOrder(event, model, collection) {
			var i, above;

			if (this._original_collection_order) {
				if (event === 'add') {
					// This is some stupid index juggling garbage
					i = collection.indexOf(model); // index as it appears in the interface currently
					above = collection.at(i - 1); // index of the item above, we'll insert after this into the original.
					i = above && this._original_collection_order.indexOf(above) || 0;
					this._original_collection_order.splice(i + 1, 0, model);
				} else if (event === 'remove') {
					// This is not particularly important
					i = this._original_collection_order.indexOf(model);
					this._original_collection_order.splice(i, 1);
				}
			}
		}
	}, {
		key: 'getOriginalModelIndex',
		value: function getOriginalModelIndex(model) {
			var models = this._original_collection_order || this.collection.models;
			return models.indexOf(model);
		}
	}, {
		key: 'calculateEntryHeight',
		value: function calculateEntryHeight() {
			if (this.forceEntryHeight) {
				return this.dimensions.rowH = this.entryHeigh = this.forceEntryHeight;
			}

			if (typeof this.dimensions.rowH === 'undefined') {
				// probably initialization phase. A dummy DOM needs to be created
				// for an entry, added to the DOM momentarily, and measured.
				// This is a bit stupid, but I don't know of a better way to measure an
				// element.
				var $entry = $(this.templates.entry.template);
				this.container.$entry.append($entry);
				this.entryHeight = Math.ceil($entry.outerHeight());
				$entry.remove();

				if (this.entryHeight === 0) {
					$('body').append($entry);
					this.entryHeight = Math.min(1, Math.ceil($entry.outerHeight()));
					$entry.remove();
				}
			}
			return this.dimensions.rowH = this.entryHeight;
		}
	}, {
		key: 'resize',
		value: function resize() {
			// calculate the height of an entry if needed
			// and then update the master container size to hold n collection
			this.calculateEntryHeight();
			this.updateViewableArea();

			if (this.collection) {
				var height = this.dimensions.rowH * this.collection.length + 'px';

				//this.container.$entry.css('height', height);
				this.container.$entries.css('height', height);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			if (this.stickyFloat !== false) {
				var topSf = new _stickyfloat2.default(this.container.$header, typeof this.stickyFloat === 'string' ? this.stickyFloat : undefined, 'top'),
				    bottomSf = new _stickyfloat2.default(this.container.$footer, typeof this.stickyFloat === 'string' ? this.stickyFloat : undefined, 'bottom');

				topSf.peer(bottomSf);
				_stickyfloat2.default.enable();
			}

			this.setDnD(this.dragAndDrop);
		}
	}, {
		key: 'updateViewableArea',
		value: function updateViewableArea(view) {
			var windowH, windowY;

			if (!this.collection) {
				return;
			}

			if (view) {
				windowY = view.windowY;
				windowH = view.windowH;
			} else {
				windowY = $(window).scrollTop();
				windowH = $(window).innerHeight();
			}

			var entryContainerY = this.getEntryContainerHorizontalOffset(),
			    collectionLength = this.collection.length,
			    d = this.dimensions,
			    lastViewYMin = d.viewYMin,
			    pad = 5;

			d.viewYMin = windowY - entryContainerY;
			d.viewYMax = windowY - entryContainerY + windowH;
			d.viewYSpan = d.viewYMax - d.viewYMin;
			d.viewYDelta = d.viewYMin === lastViewYMin ? 0 : d.viewYMin > lastViewYMin ? 1 : -1;

			d.viewRowMax = Math.max(-1, Math.min(collectionLength - 1, Math.floor(d.viewYMax / d.rowH + pad)));
			d.viewRowMin = Math.min(d.viewRowMax, Math.max(-1, Math.floor(d.viewYMin / d.rowH) - pad));
			d.viewRowSpan = Math.max(0, d.viewRowMax - d.viewRowMin);
			d.viewRowMaxSpan = Math.max(1, Math.ceil(windowH / d.rowH) + pad * 2);

			if (this.entryViewManager) {
				this.entryViewManager.update(this.dimensions);
			}
		}
	}, {
		key: 'getModelAt',
		value: function getModelAt(row) {
			return this.collection.at(row);
		}
	}, {
		key: 'setDnD',
		value: function setDnD(enable) {
			var _this7 = this;

			this.$el.toggleClass('ct-drag-and-drop', enable);
			if (enable) {
				if (!this.dnd) {
					this.dnd = new _draggable2.default(this.container.$entry, {
						draggable: '.ct-entry',
						selector: '.ct-row-number',
						callback: function callback() {
							return _this7.handleDraggableCallback.apply(_this7, arguments);
						}
					});
				}
			} else {
				if (this.dnd) {
					this.dnd.destroy();
					delete this.dnd;
				}
			}
		}
	}, {
		key: 'handleDraggableCallback',
		value: function handleDraggableCallback(position, $dropped) {
			var dim = this.dimensions;

			if (position) {
				if (!this.$droppable) {
					var $droppable = $('<div class="ct-droppable"/>');
					this.container.$entries.append($droppable);
					this.$droppable = $droppable;
				}

				var dropPosition = Math.floor(position / dim.rowH) * dim.rowH;
				this.$droppable.css({ top: dropPosition - 2 + 'px' });

				if ($dropped) {
					if (this.$droppable) {
						this.$droppable.remove();
						this.$droppable = null;
					}

					// Drag and drop should only be enabled while sorting in regular sort order
					// so no special care needs to be taken in regards to handling the original
					// sort order stuff that's required by the column sorting methods.
					var model = this.collection.get($dropped.attr('data-model-cid')),
					    models = this.collection.models,
					    fromIndex = models.indexOf(model),
					    toIndex = parseInt(position / dim.rowH, 10);

					toIndex = fromIndex < toIndex ? toIndex - 1 : toIndex;

					if (fromIndex === toIndex) {
						return;
					}

					models.splice(fromIndex, 1);
					models.splice(toIndex, 0, model);
					this.collection.trigger('sort');
				}
			}
		}
	}, {
		key: 'applyConstraints',
		value: function applyConstraints(force) {
			var cm = this.constraintManager;

			if (typeof cm !== 'undefined') {
				if (cm.pending || force) {
					cm.execute();
				}

				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;

				try {
					for (var _iterator6 = cm.modelsWithFieldDescriptions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						var _step6$value = _slicedToArray(_step6.value, 2);

						var model = _step6$value[0];
						var fields = _step6$value[1];

						var invalidations = this.invalidations.get(model.cid) || {};
						var results = {};

						var _iteratorNormalCompletion7 = true;
						var _didIteratorError7 = false;
						var _iteratorError7 = undefined;

						try {
							for (var _iterator7 = _.pairs(fields)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
								var _step7$value = _slicedToArray(_step7.value, 2);

								var field = _step7$value[0];
								var description = _step7$value[1];

								results[field] = description;
							}
						} catch (err) {
							_didIteratorError7 = true;
							_iteratorError7 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion7 && _iterator7.return) {
									_iterator7.return();
								}
							} finally {
								if (_didIteratorError7) {
									throw _iteratorError7;
								}
							}
						}

						this.invalidations.set(model.cid, results);

						var entry = this.getEntryForModel(model);
						if (entry) {
							entry.data('ct-template').applyValidationStates(_.keys((0, _diff2.default)(invalidations, results)));
						}
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 && _iterator6.return) {
							_iterator6.return();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}
			}
		}
	}, {
		key: 'validate',
		value: function validate(done, silent) {
			var i = this.collection.length - 1,
			    collection = this.collection,
			    self = this,
			    next = function next() {
				var batch = 100;
				while (batch-- > 0) {
					if (i < 0) {
						self.updateValidationStateClasses();
						return done();
					}
					self.validateModel(collection.models[i--], silent);
				}
				_.defer(next);
			};

			this.applyConstraints(true);

			next();
		}

		// return true on valid, false on invalid

	}, {
		key: 'validateSync',
		value: function validateSync(silent) {
			var models = this.collection.models;

			this.applyConstraints(true);

			for (var i = 0; i < models.length; i++) {
				this.validateModel(models[i], silent);
			}

			this.updateValidationStateClasses();

			// If the invalidations map is empty then the table contents are valid
			return this.invalidations.size === 0;
		}
	}, {
		key: 'validateModel',
		value: function validateModel(model, silent) {
			var values = model.toJSON(),
			    invalidations,
			    result,
			    results = {},
			    revalidate,
			    changes;

			// Utilize global Validation
			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = _.pairs(this.validation)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var _step8$value = _slicedToArray(_step8.value, 2);

					var field = _step8$value[0];
					var validator = _step8$value[1];

					// Compile the validation expression (these are cached, safe to call often)
					var fn = Validation.expr.compile(validator);

					var _result = fn(values[field] || '', values);
					if (_result) {
						results[field] = _result.error;
					}
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}

			if (this.constraintManager && this.constraintManager.has(model)) {
				var _iteratorNormalCompletion9 = true;
				var _didIteratorError9 = false;
				var _iteratorError9 = undefined;

				try {
					for (var _iterator9 = this.constraintManager.get(model)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
						var _step9$value = _slicedToArray(_step9.value, 2);

						var field = _step9$value[0];
						var messages = _step9$value[1];

						// Use the first validation message if there was one, and then
						// only use the first constraint message.
						results[field] = results[field] || messages[0];
					}
				} catch (err) {
					_didIteratorError9 = true;
					_iteratorError9 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion9 && _iterator9.return) {
							_iterator9.return();
						}
					} finally {
						if (_didIteratorError9) {
							throw _iteratorError9;
						}
					}
				}
			}

			// Get invalidations for the current model
			invalidations = this.invalidations.get(model.cid) || {};

			if (_.keys(results).length) {
				this.invalidations.set(model.cid, results);
			} else {
				// Invalidations should only be cleared if there are also no constraint
				// failures associated with this model.
				if (this.constraintManager && !this.constraintManager.has(model)) {
					this.invalidations.delete(model.cid);
				}
			}

			if (silent) {
				return;
			}

			// Update the entry if it's currently visible
			var entry = this.getEntryForModel(model);
			if (entry) {
				entry.data('ct-template').applyValidationStates(_.keys((0, _diff2.default)(invalidations, results)));
			}
		}

		// Update the validation class attributes on the table itself

	}, {
		key: 'updateValidationStateClasses',
		value: function updateValidationStateClasses() {
			var invalid = this.invalidations.size > 0;

			this.$el.toggleClass('invalid', invalid);

			if (!invalid && this.container && this.container.$entries) {
				this.container.$entries.find('.ui-state-error').removeClass('ui-state-error');
			}
		}
	}, {
		key: 'focusNextInvalid',
		value: function focusNextInvalid() {
			var _this8 = this;

			var field;

			var _iteratorNormalCompletion10 = true;
			var _didIteratorError10 = false;
			var _iteratorError10 = undefined;

			try {
				var _loop = function _loop() {
					var _step10$value = _slicedToArray(_step10.value, 2);

					var cid = _step10$value[0];
					var fields = _step10$value[1];

					field = Object.keys(fields)[0];

					var model = _this8.collection.get(cid);
					_this8.focusModel(model);
					/*jshint -W083*/
					_this8.scrollTo(model, function () {
						_.defer(function () {
							// focus the field, that will trigger an entry focus as well.
							var template = _this8.getEntryForModel(model).data('ct-template');
							template.focusField(field);
						});
					});
					/*jshint +W083*/
					return {
						v: void 0
					};
				};

				for (var _iterator10 = this.invalidations.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
					var _ret4 = _loop();

					if ((typeof _ret4 === 'undefined' ? 'undefined' : _typeof(_ret4)) === "object") return _ret4.v;
				}
			} catch (err) {
				_didIteratorError10 = true;
				_iteratorError10 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion10 && _iterator10.return) {
						_iterator10.return();
					}
				} finally {
					if (_didIteratorError10) {
						throw _iteratorError10;
					}
				}
			}
		}

		// Returns an object containing details about invalid items
		// in the data collection.

	}, {
		key: 'getTableData',
		value: function getTableData(noValidate) {
			if (!noValidate) {
				this.validateSync();
			}

			this.modifications.clear();
			this.sortCollection('_row', 'numeric', null, 'desc');
			return this.collection.toJSON();
		}

		// Returns true if any modifications have been made to the associated collection.
		// Returns false after `resetModifiedStatus()` has been called.

	}, {
		key: 'resetModifiedStatus',
		value: function resetModifiedStatus() {
			this.state.set('modified', false);
		}
	}, {
		key: 'invalid',
		get: function get() {
			var result = [],
			    m2v = this.templates.entry.bindings.m2v;

			var _iteratorNormalCompletion11 = true;
			var _didIteratorError11 = false;
			var _iteratorError11 = undefined;

			try {
				for (var _iterator11 = this.invalidations.entries()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
					var _step11$value = _slicedToArray(_step11.value, 2);

					var cid = _step11$value[0];
					var fields = _step11$value[1];

					var elements = {};
					var _iteratorNormalCompletion12 = true;
					var _didIteratorError12 = false;
					var _iteratorError12 = undefined;

					try {
						for (var _iterator12 = _.keys(fields)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
							var field = _step12.value;

							elements[field] = m2v[field];
						}
					} catch (err) {
						_didIteratorError12 = true;
						_iteratorError12 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion12 && _iterator12.return) {
								_iterator12.return();
							}
						} finally {
							if (_didIteratorError12) {
								throw _iteratorError12;
							}
						}
					}

					result.push({
						cid: cid, // Associated model.cid
						elements: elements, // Keys are model attribute names, value is an array of element names
						errors: fields });
				}
			} catch (err) {
				_didIteratorError11 = true;
				_iteratorError11 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion11 && _iterator11.return) {
						_iterator11.return();
					}
				} finally {
					if (_didIteratorError11) {
						throw _iteratorError11;
					}
				}
			}

			// Keys are model attribute names, value is error string
			return result;
		}
	}, {
		key: 'hasBeenModified',
		get: function get() {
			return this.state.get('modified', false);
		}
	}], [{
		key: 'get',
		value: function get(element) {
			return $(element).data(ConfigTableDataName);
		}
	}]);

	return ConfigTable;
}();

ConfigTable.prototype.actions = {

	delete: function _delete($entry) {
		var model = this.getModelForEntry($entry);
		this.collection.remove(model);
		return false;
	},

	append: function append($entry) {
		var newModel = void 0;

		// if $entry is provided, then insert after
		if ($entry) {
			var _model = this.getModelForEntry($entry),
			    index = this.collection.indexOf(_model);
			newModel = this.modelInit(index + 1);
			this.collection.add(newModel, { at: index + 1 });
		} else {
			newModel = this.modelInit();
			this.collection.push(newModel);
		}

		this.focusModel(newModel);
		this.scrollTo(newModel);
		return false;
	}
};

var VERSION = exports.VERSION = '2.0.14';

function init(options) {
	return new ConfigTable(options);
}

function get(selector) {
	return ConfigTable.get(selector);
}

_.extend(ConfigTable.prototype, Backbone.Events);

exports.ConfigTable = ConfigTable;

},{"./constraintmanager":3,"./diff":4,"./draggable":5,"./entryviewmanager":7,"./sortmethods":9,"./stickyfloat":10,"./template-builder":11}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.commaJoin = commaJoin;

var _collectionutil = require('./collectionutil');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var constraintMethods = {
	unique: {
		description: function description(fields, params) {
			var msg = '';
			if (params && params.models && params.models.length) {
				var rows = params.models.filter(function (model) {
					return model !== params.model;
				}).map(function (model) {
					return params.constraintManager.getIndex(model) + 1;
				});

				msg = 'Duplicate found on row(s): ' + commaJoin(rows) + '.';
			}

			if (fields.length === 1) {
				return [msg, 'The ' + fields[0] + ' field must be unique'].join(' ');
			} else if (fields.length == 2) {
				return [msg, fields[0] + ' and ' + fields[1] + ' fields must be unique together'].join(' ');
			}
			return [msg, commaJoin(fields) + ' fields must be unique. '].join(' ');
		},
		method: function method(collection, fields) {
			return (0, _collectionutil.duplicates)(collection, fields);
		}
	}
};

function commaJoin(arr) {
	if (arr.length === 0) {
		return '';
	}

	if (arr.length === 1) {
		return arr[0];
	}

	if (arr.length === 2) {
		return arr[0] + ' and ' + arr[1];
	}

	return arr.slice(0, arr.length - 1).join(', ') + ', and ' + arr[arr.length - 1];
}

function buildConstraintMethod(name, fields) {
	var cm = constraintMethods[name];

	return function (collection) {
		return {
			name: name,
			fields: fields,
			description: function description(params) {
				return cm.description(fields, params);
			},
			data: cm.method(collection, fields)
		};
	};
}

var ConstraintManager = function () {
	function ConstraintManager(collection, constraints, options) {
		_classCallCheck(this, ConstraintManager);

		this.collection = collection;
		this.constraints = [];
		this.parseConstraints(constraints);
		this.addListeners();

		this.pendingConstraints = new Set();
		this.constraintMethodResults = new Map();

		this.getIndex = options.getIndex || function (model) {
			return collection.indexOf(model) + 1;
		};
	}

	_createClass(ConstraintManager, [{
		key: 'addListeners',
		value: function addListeners() {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.watchFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _step$value = _slicedToArray(_step.value, 2);

					var field = _step$value[0];
					var funcs = _step$value[1];

					this.listenTo(this.collection, 'change:' + field, this.onFieldChanged);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}
	}, {
		key: 'parseConstraints',
		value: function parseConstraints(constraints) {
			var watchFields = new Map(),
			    constraintMethods = new Set();

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = _.pairs(constraints)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var _step2$value = _slicedToArray(_step2.value, 2);

					var constraint = _step2$value[0];
					var groups = _step2$value[1];
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {

						for (var _iterator3 = groups[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var fields = _step3.value;

							var fn = buildConstraintMethod(constraint, fields);

							constraintMethods.add(fn);

							var _iteratorNormalCompletion4 = true;
							var _didIteratorError4 = false;
							var _iteratorError4 = undefined;

							try {
								for (var _iterator4 = fields[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									var field = _step4.value;

									var wf = watchFields.get(field);
									if (wf) {
										wf.push(fn);
									} else {
										watchFields.set(field, [fn]);
									}
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4.return) {
										_iterator4.return();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			this.watchFields = watchFields;
			this.constraintMethods = constraintMethods;
		}

		// This method doesn't actually run any constraints, it only
		// adds the constraints that should be run based on modifications
		// to fields. You must call call executePendingConstraints() to
		// get the results.

	}, {
		key: 'onFieldChanged',
		value: function onFieldChanged(model, value) {
			var changed = _.keys(model.changed);

			// Iterate through changed fields and construct a set of
			// constraint methods that are related to the changed fields.
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = changed[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var field = _step5.value;

					var watchField = this.watchFields.get(field);
					var _iteratorNormalCompletion6 = true;
					var _didIteratorError6 = false;
					var _iteratorError6 = undefined;

					try {
						for (var _iterator6 = watchField[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
							var func = _step6.value;

							// Using a set means we won't potentially call the same
							// constraint method twice in the same sweep.
							this.pendingConstraints.add(func);
						}
					} catch (err) {
						_didIteratorError6 = true;
						_iteratorError6 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion6 && _iterator6.return) {
								_iterator6.return();
							}
						} finally {
							if (_didIteratorError6) {
								throw _iteratorError6;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}
	}, {
		key: 'execute',
		value: function execute() {
			var methods = this.pending ? this.pendingConstraints : this.constraintMethods,
			    models = new Set(),
			    resultGroups = new Map();

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = methods[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var fn = _step7.value;

					var result = fn(this.collection),
					    invalidations = new Map();

					if (result.data.length) {
						var _iteratorNormalCompletion8 = true;
						var _didIteratorError8 = false;
						var _iteratorError8 = undefined;

						try {
							for (var _iterator8 = result.data[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
								var group = _step8.value;

								var record = {
									descriptionFn: result.description,
									fields: result.fields,
									models: group
								};

								var _iteratorNormalCompletion9 = true;
								var _didIteratorError9 = false;
								var _iteratorError9 = undefined;

								try {
									for (var _iterator9 = group[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
										var model = _step9.value;

										// Assign the record to each cid contained within
										// the group set.
										invalidations.set(model, record);
										models.add(model);
									}
								} catch (err) {
									_didIteratorError9 = true;
									_iteratorError9 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion9 && _iterator9.return) {
											_iterator9.return();
										}
									} finally {
										if (_didIteratorError9) {
											throw _iteratorError9;
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError8 = true;
							_iteratorError8 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion8 && _iterator8.return) {
									_iterator8.return();
								}
							} finally {
								if (_didIteratorError8) {
									throw _iteratorError8;
								}
							}
						}
					}

					this.constraintMethodResults.set(fn, invalidations);
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			this.pendingConstraints = new Set();
		}
	}, {
		key: 'has',


		// Returns true if the provided cid has a constraint issue related to it.
		// This is more efficient than calling `cids` if you just need to check
		// one field.
		value: function has(model) {
			if (typeof model === 'string') {
				model = this.collection.get(model);
			}

			var _iteratorNormalCompletion10 = true;
			var _didIteratorError10 = false;
			var _iteratorError10 = undefined;

			try {
				for (var _iterator10 = this.constraintMethodResults.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
					var _step10$value = _slicedToArray(_step10.value, 2);

					var fn = _step10$value[0];
					var map = _step10$value[1];

					if (map.has(model)) {
						return true;
					}
				}
			} catch (err) {
				_didIteratorError10 = true;
				_iteratorError10 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion10 && _iterator10.return) {
						_iterator10.return();
					}
				} finally {
					if (_didIteratorError10) {
						throw _iteratorError10;
					}
				}
			}

			return false;
		}

		// Get fields and error descriptions for model or cid

	}, {
		key: 'get',
		value: function get(model) {
			if (typeof model === 'string') {
				model = this.collection.get(model);
			}

			var fields = new Map();

			var _iteratorNormalCompletion11 = true;
			var _didIteratorError11 = false;
			var _iteratorError11 = undefined;

			try {
				for (var _iterator11 = this.constraintMethodResults.entries()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
					var _step11$value = _slicedToArray(_step11.value, 2);

					var fn = _step11$value[0];
					var map = _step11$value[1];

					var record = map.get(model);

					if (record) {
						var description = record.descriptionFn({
							model: model,
							constraintManager: this,
							collection: this.collection,
							models: record.models
						});

						var _iteratorNormalCompletion12 = true;
						var _didIteratorError12 = false;
						var _iteratorError12 = undefined;

						try {
							for (var _iterator12 = record.fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
								var field = _step12.value;

								var descriptions = fields.get(field);
								if (!descriptions) {
									descriptions = [description];
									fields.set(field, descriptions);
								} else {
									descriptions.push(description);
								}
							}
						} catch (err) {
							_didIteratorError12 = true;
							_iteratorError12 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion12 && _iterator12.return) {
									_iterator12.return();
								}
							} finally {
								if (_didIteratorError12) {
									throw _iteratorError12;
								}
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError11 = true;
				_iteratorError11 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion11 && _iterator11.return) {
						_iterator11.return();
					}
				} finally {
					if (_didIteratorError11) {
						throw _iteratorError11;
					}
				}
			}

			return fields;
		}
	}, {
		key: 'modelsRelatedTo',
		value: function modelsRelatedTo(model, fields) {
			var models = new Set();

			// Collect all the functions related to the specified fields into
			// the functions set.
			var functions = void 0;
			if (fields) {
				functions = new Set();
				var _iteratorNormalCompletion13 = true;
				var _didIteratorError13 = false;
				var _iteratorError13 = undefined;

				try {
					for (var _iterator13 = new Set(fields)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
						var field = _step13.value;

						if (this.watchFields.has(field)) {
							var _iteratorNormalCompletion14 = true;
							var _didIteratorError14 = false;
							var _iteratorError14 = undefined;

							try {
								for (var _iterator14 = this.watchFields.get(field)[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
									var fn = _step14.value;

									functions.add(fn);
								}
							} catch (err) {
								_didIteratorError14 = true;
								_iteratorError14 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion14 && _iterator14.return) {
										_iterator14.return();
									}
								} finally {
									if (_didIteratorError14) {
										throw _iteratorError14;
									}
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError13 = true;
					_iteratorError13 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion13 && _iterator13.return) {
							_iterator13.return();
						}
					} finally {
						if (_didIteratorError13) {
							throw _iteratorError13;
						}
					}
				}
			} else {
				functions = this.constraintMethods;
			}

			var _iteratorNormalCompletion15 = true;
			var _didIteratorError15 = false;
			var _iteratorError15 = undefined;

			try {
				for (var _iterator15 = functions[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
					var _fn = _step15.value;

					var map = this.constraintMethodResults.get(_fn);
					var _iteratorNormalCompletion16 = true;
					var _didIteratorError16 = false;
					var _iteratorError16 = undefined;

					try {
						for (var _iterator16 = map.keys()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
							var _model = _step16.value;

							models.add(_model);
						}
					} catch (err) {
						_didIteratorError16 = true;
						_iteratorError16 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion16 && _iterator16.return) {
								_iterator16.return();
							}
						} finally {
							if (_didIteratorError16) {
								throw _iteratorError16;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError15 = true;
				_iteratorError15 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion15 && _iterator15.return) {
						_iterator15.return();
					}
				} finally {
					if (_didIteratorError15) {
						throw _iteratorError15;
					}
				}
			}

			return models;
		}
	}, {
		key: 'pending',
		get: function get() {
			return this.pendingConstraints.size > 0;
		}

		// Returns a all models that have related constraint issues.

	}, {
		key: 'models',
		get: function get() {
			var models = new Set();
			var _iteratorNormalCompletion17 = true;
			var _didIteratorError17 = false;
			var _iteratorError17 = undefined;

			try {
				for (var _iterator17 = this.constraintMethodResults.entries()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
					var _step17$value = _slicedToArray(_step17.value, 2);

					var fn = _step17$value[0];
					var map = _step17$value[1];
					var _iteratorNormalCompletion18 = true;
					var _didIteratorError18 = false;
					var _iteratorError18 = undefined;

					try {
						for (var _iterator18 = map.keys()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
							var model = _step18.value;

							models.add(model);
						}
					} catch (err) {
						_didIteratorError18 = true;
						_iteratorError18 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion18 && _iterator18.return) {
								_iterator18.return();
							}
						} finally {
							if (_didIteratorError18) {
								throw _iteratorError18;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError17 = true;
				_iteratorError17 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion17 && _iterator17.return) {
						_iterator17.return();
					}
				} finally {
					if (_didIteratorError17) {
						throw _iteratorError17;
					}
				}
			}

			return models;
		}
	}, {
		key: 'modelsWithFieldDescriptions',
		get: function get() {
			var models = new Map();

			var _iteratorNormalCompletion19 = true;
			var _didIteratorError19 = false;
			var _iteratorError19 = undefined;

			try {
				for (var _iterator19 = this.constraintMethodResults.entries()[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
					var _step19$value = _slicedToArray(_step19.value, 2);

					var fn = _step19$value[0];
					var map = _step19$value[1];
					var _iteratorNormalCompletion20 = true;
					var _didIteratorError20 = false;
					var _iteratorError20 = undefined;

					try {
						for (var _iterator20 = map[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
							var _step20$value = _slicedToArray(_step20.value, 2);

							var model = _step20$value[0];
							var record = _step20$value[1];

							var description = record.descriptionFn({
								model: model,
								constraintManager: this,
								collection: this.collection,
								models: record.models
							});

							var result = models.get(model) || {};

							var _iteratorNormalCompletion21 = true;
							var _didIteratorError21 = false;
							var _iteratorError21 = undefined;

							try {
								for (var _iterator21 = record.fields[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
									var field = _step21.value;

									result[field] = description;
								}
							} catch (err) {
								_didIteratorError21 = true;
								_iteratorError21 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion21 && _iterator21.return) {
										_iterator21.return();
									}
								} finally {
									if (_didIteratorError21) {
										throw _iteratorError21;
									}
								}
							}

							models.set(model, result);
						}
					} catch (err) {
						_didIteratorError20 = true;
						_iteratorError20 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion20 && _iterator20.return) {
								_iterator20.return();
							}
						} finally {
							if (_didIteratorError20) {
								throw _iteratorError20;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError19 = true;
				_iteratorError19 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion19 && _iterator19.return) {
						_iterator19.return();
					}
				} finally {
					if (_didIteratorError19) {
						throw _iteratorError19;
					}
				}
			}

			return models;
		}
	}]);

	return ConstraintManager;
}();

exports.default = ConstraintManager;


_.extend(ConstraintManager.prototype, Backbone.Events);

},{"./collectionutil":1}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = diff;
function diff(a, b, ignore) {
	// Return all attributes in B that differ from A
	var result = {},
	    aKeys = [],
	    x,
	    i;

	ignore = ignore || [];

	// Build array of all of A's keys
	for (x in a) {
		if (ignore.indexOf(x) > -1) {
			continue;
		}
		if (a.hasOwnProperty(x)) {
			aKeys.push(x);
		}
	}

	for (x in b) {
		if (ignore.indexOf(x) > -1) {
			continue;
		}
		if (b.hasOwnProperty(x)) {
			// If they differ, store B's value
			if (a[x] !== b[x]) {
				result[x] = b[x];
			}
			// Remove the key from aKeys since it's been handled
			i = aKeys.indexOf(x);
			if (i > -1) {
				aKeys.splice(i, 1);
			}
		}
	}

	// Any of the remaining A keys were removed
	// from B, so they are injected them as undefined values.
	for (i in aKeys) {
		result[aKeys[i]] = undefined;
	}

	return result;
}
module.exports = exports['default'];

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ns = '.ct-draggable';

var Draggable = function () {
	function Draggable($el, options) {
		var _this = this;

		_classCallCheck(this, Draggable);

		this.$el = $el;
		this.callback = options.callback;
		this.dragHandle = options.selector;
		this.getDragElement = function (event) {
			return $(event.target).closest(options.draggable);
		};
		this.threshold = options.threshold || 250;
		this.scrollSpeed = options.scrollSpeed || 2;
		this.$el.on(this.dragHandle + ' mousedown' + ns, this.dragHandle, function (e) {
			return _this.onMouseDown(e);
		});
		this.scrolling = false;
	}

	_createClass(Draggable, [{
		key: 'destroy',
		value: function destroy() {
			this.$el.off('mousedown' + ns);
		}
	}, {
		key: 'addListeners',
		value: function addListeners(dragHandle) {
			var _this2 = this;

			$(window).on('mousemove' + ns, function (e) {
				return _this2.onMouseMove(e);
			}).on('mouseup' + ns, function (e) {
				return _this2.onMouseUp(e);
			});
		}
	}, {
		key: 'removeListeners',
		value: function removeListeners() {
			$(window).off('mousemove' + ns).off('mouseup' + ns);
		}
	}, {
		key: 'onMouseDown',
		value: function onMouseDown(e) {
			// store the element that the drag started on
			this.$sourceElement = this.getDragElement(e);
			this.startY = window.pageYOffset + e.clientY;
			this.dragging = false;
			this.addListeners();
			e.preventDefault();

			// determine scroll threshold boundaries
			var windowHeight = this.windowHeight = $(window).innerHeight();
			this.scrollMin = this.threshold;
			this.scrollMax = windowHeight - this.threshold;
			return false;
		}
	}, {
		key: 'onMouseMove',
		value: function onMouseMove(e) {
			var delta = window.pageYOffset + e.clientY - this.startY,
			    y = e.clientY;

			this.clientY = y;

			if (this.dragging) {
				if (!this.scrolling && (y < this.scrollMin || y > this.scrollMax)) {
					this.onScrollStart(y);
				}
				return this.onDrag(delta);
			}

			this.dragging = Math.abs(delta) > 3;

			if (this.dragging) {
				return this.onDragStart();
			}
		}
	}, {
		key: 'onMouseUp',
		value: function onMouseUp(e) {
			var delta = window.pageYOffset + e.clientY - this.startY;

			this.onScrollStop();
			if (this.dragging) {
				this.onDragEnd(delta);
			}
			this.removeListeners();
		}
	}, {
		key: 'onDragStart',
		value: function onDragStart(startY) {
			this.$draggable = this.$sourceElement.clone().addClass('dragging');

			this.$sourceElement.parent().append(this.$draggable);

			var top = this.$sourceElement.position().top;
			var height = this.$sourceElement.outerHeight();

			this.dragElementTop = top;

			this.gapPosition = function (delta) {
				return top + height + delta;
			};

			this.callback(this.gapPosition(0));
		}
	}, {
		key: 'onDrag',
		value: function onDrag(delta) {
			this.$draggable.css('transform', 'translateY(' + (this.dragElementTop + delta) + 'px)');
			this.callback(this.gapPosition(delta));
		}
	}, {
		key: 'onDragEnd',
		value: function onDragEnd(delta) {
			this.$draggable.remove();
			this.callback(this.gapPosition(delta), this.$sourceElement);
		}
	}, {
		key: 'onScrollStart',
		value: function onScrollStart(y) {
			var last,
			    self = this,
			    min = this.scrollMin,
			    max = this.scrollMax,
			    thresh = this.threshold,
			    speed = this.scrollSpeed,
			    update = function update(timestamp) {
				var delta = (timestamp - (last || timestamp)) * speed,
				    adjust = void 0;

				if (self.clientY < min) {
					adjust = (min - self.clientY) / thresh * delta * -1;
				} else if (self.clientY > max) {
					adjust = (self.clientY - max) / thresh * delta;
				} else {
					return self.onScrollStop();
				}

				if (adjust) {
					adjust = Math.ceil(adjust);
					window.scrollBy(0, adjust);
					self.onDrag(window.pageYOffset + self.clientY - self.startY);
				}

				if (self.scrolling) {
					requestAnimationFrame(update);
				}

				last = timestamp;
			};

			requestAnimationFrame(update);
			this.scrolling = true;
		}
	}, {
		key: 'onScrollStop',
		value: function onScrollStop() {
			this.scrolling = false;
		}
	}]);

	return Draggable;
}();

exports.default = Draggable;
exports.Draggable = Draggable;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EntryPool = function () {
	function EntryPool(options) {
		_classCallCheck(this, EntryPool);

		this.getParentElement = options.getParentElement;
		this.buildEntry = options.buildEntry;
		this.entries = [];
		this._index = 0;
		this._width = 0;
	}

	_createClass(EntryPool, [{
		key: "reset",
		value: function reset() {
			this._index = 0;
			this._width = 0;

			for (var i = 0; i < this.entries.length; i++) {
				this.entries[i].$el.hide();
			}
		}
	}, {
		key: "growBy",
		value: function growBy(n) {
			var elements = [],
			    $parent = this.getParentElement();

			if (!$parent) {
				throw Error("couldn't get parent element");
			}

			for (var i = 0; i < n; i++) {
				var entry = this.buildEntry();
				this.entries.push(entry);
				elements.push(entry.$el);
				entry.$el.hide(); //css('top', '-20em');
			}

			$parent.append(elements);
		}
	}, {
		key: "forward",
		value: function forward() {
			var i = this._index;
			this._width = Math.min(this._width + 1, this.entries.length);

			this._index = (this._index + 1) % this.entries.length;

			return i;
		}
	}, {
		key: "backward",
		value: function backward() {
			var i = this._index - this._width - 1;

			if (this._width < this.entries.length) {
				this._width++;
			} else {
				this._index--;
				while (this._index < 0) {
					this._index += this.entries.length;
				}
			}

			while (i < 0) {
				i = this.entries.length + i;
			}

			return i;
		}
	}, {
		key: "index",
		value: function index() {
			var i = this._index % this.entries.length;
			while (i < 0) {
				i += this.entries.length;
			}
			this._index = i;
			return i;
		}
	}, {
		key: "get",
		value: function get(delta) {
			var e = void 0;

			if (delta > 0) {
				e = this.entries[this.forward()];
			} else {
				e = this.entries[this.backward()];
			}

			return e;
		}
	}, {
		key: "length",
		get: function get() {
			return this.entries.length;
		}
	}]);

	return EntryPool;
}();

exports.default = EntryPool;
module.exports = exports['default'];

},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _entrypool = require('./entrypool');

var _entrypool2 = _interopRequireDefault(_entrypool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EntryViewManager = function () {
	function EntryViewManager(options) {
		_classCallCheck(this, EntryViewManager);

		this.options = options;

		this.getCollection = options.getCollection;
		this.getModelAt = options.getModelAt;
		this.getEntryInit = options.getEntryInit;

		this.entryPool = new _entrypool2.default({
			buildEntry: options.buildEntry,
			getParentElement: options.getEntryParentElement
		});

		this.reset();
	}

	_createClass(EntryViewManager, [{
		key: 'reset',
		value: function reset() {
			this.entryPool.reset();
			this.viewRowMin = -1;
			this.viewRowMax = -1;
		}
	}, {
		key: 'prepareElement',
		value: function prepareElement(delta, row) {
			var item = this.entryPool.get(delta);
			var model = this.getModelAt(row);

			item.setModel(model, {
				_row: this.options.getIndex(model) + 1
			});

			this.getEntryInit()(item, model);

			item.$el.show();

			return item.$el;
		}
	}, {
		key: 'update',
		value: function update(dim) {
			var collection = this.getCollection();

			// If either there's been a large screen adjustment or the viewable
			// area exceeds the currently viewed area.
			if (dim.viewRowMax < this.viewRowMin || dim.viewRowMin > this.viewRowMax || dim.viewRowMaxSpan > this.entryPool.entries.length) {
				if (dim.viewRowMaxSpan > this.entryPool.entries.length) {
					this.entryPool.growBy(dim.viewRowMaxSpan - this.entryPool.entries.length);
				}

				this.reset();
				this.viewRowMax = this.viewRowMin = dim.viewRowMin;
				dim.viewYDelta = 0;
			}

			if (dim.viewYDelta > -1) {
				// scrolling down
				while (this.viewRowMax < dim.viewRowMax) {
					this.viewRowMax++;
					var row = this.viewRowMax;
					var $el = this.prepareElement(1, row);
					$el.css('transform', 'translateY(' + row * dim.rowH + 'px)');
				}
				this.viewRowMin = Math.max(this.viewRowMax - dim.viewRowMaxSpan, this.viewRowMin);
			} else {
				// scrolling up
				while (this.viewRowMin > dim.viewRowMin) {
					var _row = this.viewRowMin;
					this.viewRowMin--;
					var _$el = this.prepareElement(-1, _row);
					_$el.css('transform', 'translateY(' + _row * dim.rowH + 'px)');
				}
				this.viewRowMax = Math.min(this.viewRowMax, this.viewRowMin + dim.viewRowMaxSpan);
			}
		}
	}]);

	return EntryViewManager;
}();

exports.default = EntryViewManager;
module.exports = exports['default'];

},{"./entrypool":6}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	'ct2-autofill': function ct2Autofill(o) {
		return (/ct-autofill-(from|to|bidi)/.test(o.className)
		);
	},
	'ct2-autofill-from': function ct2AutofillFrom(o) {
		return (/ct-autofill-(from|bidi)/.test(o.className)
		);
	},
	'ct2-autofill-to': function ct2AutofillTo(o) {
		return (/ct-autofill-(to|bidi)/.test(o.className)
		);
	},
	'ct2-sortby': function ct2Sortby(o) {
		return (/ct-sortby-([\w]+)/.test(o.className)
		);
	},
	'ct2-bind': function ct2Bind(o) {
		return o.getAttribute('data-ct-bind');
	},
	'ct2-id': function ct2Id(o) {
		return o.getAttribute('data-ct-id');
	},
	'ct2-action': function ct2Action(o) {
		return o.getAttribute('data-ct-action');
	},
	'ct2-validate': function ct2Validate(o) {
		return o.getAttribute('data-ct-validate');
	},
	'configtable': function configtable(o) {
		return $(o).hasClass('configtable') && $(o).data('configtable');
	}
};
module.exports = exports['default'];

},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	default: function _default(a, b) {
		var a1,
		    b1,
		    i = 0,
		    rx = /(\d+)|(\D+)/g,
		    rd = /\d/,
		    L;

		if (isFinite(a) && isFinite(b)) {
			return a - b;
		}

		a = String(a).toLowerCase();
		b = String(b).toLowerCase();
		if (a === b) {
			return 0;
		}
		if (!(rd.test(a) && rd.test(b))) {
			return a > b ? 1 : -1;
		}

		a = a.match(rx);
		b = b.match(rx);
		L = a.length > b.length ? b.length : a.length;
		while (i < L) {
			a1 = a[i];
			b1 = b[i];
			i = i + 1;
			if (a1 !== b1) {
				if (isFinite(a1) && isFinite(b1)) {
					if (a1.charAt(0) === '0') {
						a1 = '.' + a1;
					}
					if (b1.charAt(0) === '0') {
						b1 = '.' + b1;
					}
					return b1 - a1;
				}
				return a1 > b1 ? 1 : -1;
			}
		}
		return a.length - b.length;
	},

	autonumber: function autonumber(a, b) {
		// Strip leading zeroes, colons, and commas
		a = a.replace(/^0*/, '').replace(/[:,]/g, '');
		b = b.replace(/^0*/, '').replace(/[:,]/g, '');

		a = a || 0;
		b = b || 0;

		return a - b;
	},

	ip: function ip(a, b) {
		var aa = a.split('.'),
		    ba = b.split('.'),
		    L = Math.min(aa.length, ba.length),
		    i,
		    c;

		for (i = 0; i < L; i = i + 1) {
			c = aa[i] - ba[i];
			if (c !== 0) {
				return c;
			}
		}
		return 0;
	},

	subnet: function subnet(a, b) {
		var ip_sort_result,
		    aa = a.split('/'),
		    /* ['172.17.0.0', '24'] */
		bb = b.split('/'),
		    a_mask = parseInt(aa[1], 10),
		    b_mask = parseInt(bb[1], 10);

		return a_mask === b_mask ? $.cipa.configtable.sortmethods.ip(aa[0], bb[0]) : b_mask - a_mask;
	},

	string: function string(a, b) {
		return a < b ? -1 : a > b ? 1 : 0;
	}
};
module.exports = exports['default'];

},{}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _stickyfloats = new Map(),
    _listening = false,
    deferUpdate = _.throttle(update, 0);

function updateTopGroupset(groupset, dim) {
	var accum = 0;
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = groupset[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var sf = _step.value;

			var y = sf.top + accum;
			var h = sf.height;
			var peerOffset = sf.peer && Math.min(0, sf.peer.top - h - dim.yMin) || 0;

			if (sf.floating && y > dim.yMin || peerOffset < -h) {
				sf.sink();
			} else if (!sf.floating && y < dim.yMin) {
				sf.float();
			}
			accum += sf.update(accum + peerOffset);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}
}

function updateBottomGroupset(groupset, dim) {
	var accum = 60; // FIXME This should be 0, this only compensates for the save/apply bar
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = groupset[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var sf = _step2.value;

			var y = sf.bottom - accum;
			var h = sf.height;
			var peerOffset = sf.peer && Math.max(0, sf.peer.bottom + h - dim.yMax) || 0;

			if (sf.floating && y < dim.yMax || peerOffset > h) {
				sf.sink();
			} else if (!sf.floating && y > dim.yMax) {
				sf.float();
			}
			accum += sf.update(accum - peerOffset);
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}
}

function update() {
	var windowY = $(window).scrollTop();
	var windowH = $(window).innerHeight();

	// FIXME
	// This is a hack for the current Cipafilter interface, which uses the old
	// stickyfloats for the save bar at the bottom. The save bar should eventually
	// use new stickyfloats and this hack should be removed.
	windowH -= 60;

	var dim = {
		yMax: windowH + windowY,
		yMin: windowY
	};

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = _stickyfloats[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var _step3$value = _slicedToArray(_step3.value, 2);

			var groupname = _step3$value[0];
			var grouplist = _step3$value[1];
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = grouplist[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var _step4$value = _slicedToArray(_step4.value, 2);

					var attachment = _step4$value[0];
					var groupset = _step4$value[1];

					if (attachment === 'top') {
						updateTopGroupset(groupset, dim);
					} else {
						updateBottomGroupset(groupset, dim);
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}
}

function enable() {
	if (!_listening) {
		$(window).on('scroll.stickyfloat resize.stickyfloat', update);
		_listening = true;
	}
}

function disable() {
	$(window).off('.stickyfloat');
	_listening = false;
}

var StickyFloat = function () {
	function StickyFloat(element, group, attachment) {
		_classCallCheck(this, StickyFloat);

		var $el;

		if (attachment !== 'top' && attachment !== 'bottom') {
			throw Error('stickyfloat attachment must be either "top" or "bottom".');
		}

		this.$el = $el = $(element);
		this.group = group = group || 'default';
		this.attachment = attachment;
		this.floating = false;

		this.$el.data('stickyfloat', this);

		var grouplist = void 0;
		if (_stickyfloats.has(group)) {
			grouplist = _stickyfloats.get(group);
		} else {
			grouplist = new Map([['top', []], ['bottom', []]]);
			_stickyfloats.set(group, grouplist);
		}

		var groupset = grouplist.get(attachment);

		groupset.push(this);

		// sort by y component
		if (attachment === 'top') {
			groupset.sort(function (a, b) {
				return a.top - b.top;
			});
		} else {
			groupset.sort(function (b, a) {
				return a.top - b.top;
			});
		}

		deferUpdate();
	}

	_createClass(StickyFloat, [{
		key: 'peer',
		value: function peer(other) {
			this.peer = other;
			other.peer = this;
		}
	}, {
		key: 'remove',
		value: function remove() {
			var group = _stickyfloats[this.group];
			group.splice(group.indexOf(this), 1);
			this.$el.data('stickyfloat', undefined);
		}
	}, {
		key: 'float',
		value: function float() {
			var $el = this.$el,
			    $parent = this.$el.parent(),
			    lastWidth,
			    lastHeight,
			    syncAppearance;

			if (!this.floating) {

				var attachment = this.attachment;

				lastWidth = $el.outerWidth();
				lastHeight = $el.outerHeight();

				var $floated = $('<div class="sf-float-' + attachment + '" />'); //style="position: fixed; width: inherit"/>`);
				var $placeholder = $('<div class="sf-pl" />').outerHeight(lastHeight);

				$placeholder.insertAfter($el);
				$el.remove();
				$floated.append($el);
				$parent.append($floated);

				this.$floated = $floated;
				this.$placeholder = $placeholder;
				this.floating = true;
			}
		}
	}, {
		key: 'sink',
		value: function sink() {
			if (this.floating) {
				var $floated = this.$floated;
				var $placeholder = this.$placeholder;
				var $el = this.$el;

				$floated.remove();
				$el.remove();
				$el.insertAfter($placeholder);
				$placeholder.remove();

				this.floating = false;
			}
		}
	}, {
		key: 'update',
		value: function update(offset) {
			if (this.floating) {
				if (this._lastOffset !== offset) {
					this._lastOffset = offset;

					if (this.attachment === 'top') {
						this.$floated.css({ top: offset + 'px' });
					} else {
						this.$floated.css({ bottom: offset + 'px' });
					}
				}

				return this.$floated.outerHeight();
			} else {
				this._lastOffset = null;
			}

			return 0;
		}
	}, {
		key: 'height',
		get: function get() {
			return this.$el.outerHeight();
		}
	}, {
		key: 'top',
		get: function get() {
			return this.floating ? this.$placeholder.offset().top : this.$el.offset().top;
		}
	}, {
		key: 'bottom',
		get: function get() {
			return this.height + this.top;
		}
	}]);

	return StickyFloat;
}();

exports.default = StickyFloat;


StickyFloat.enable = enable;
StickyFloat.disable = disable;
module.exports = exports['default'];

},{}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = compileTemplate;

var _jquerySelectors = require('./jquery-selectors');

var _jquerySelectors2 = _interopRequireDefault(_jquerySelectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

if (typeof $ !== 'undefined') {
	$.extend($.expr[':'], _jquerySelectors2.default);
}

var uniqId = function () {
	var i = 0;
	return function () {
		return 'cte-' + (i++).toString(16);
	};
}();

// pass template to compileTemplate, get back a prepared template
// call prepared template and get back a template that's all set up with
// an element.

function isTruthy(x) {
	return typeof x === 'boolean' ? x : Boolean(x) && !(x.length === 0 || x[0] === 'f' || x[0] === 'F' || x === '0');
}

function compileTemplate(template, options) {
	var $template = $(template).not(':text');

	if ($template.length > 1) {
		throw Error('The template provided for "' + options.name + '" has more than one root element.');
	}
	// Entry field templates need to have an element prepended
	// to hold the entry number.
	if (options.showPosition) {
		if (options.name === 'header') {
			$template.prepend('<span class="ct-row-number ct-header-item ct-sortby-_row-numeric sort-desc"><span class="ct-row-sort"></span></span>');
		} else if (options.name === 'entry') {
			$template.prepend('<span class="ct-row-number"><span data-ct-bind="_row">x</span></span>');
		}
	}

	// Parse/extract all "bind" elements from the template
	var bindingExpr = /([<>]*)(\w+)/;
	var bindElements = $template.find(':ct2-bind');

	var bindings = {};
	var m2v = bindings.m2v = {};
	var v2m = bindings.v2m = {};
	var methods = bindings.methods = {};

	$(bindElements).each(function (i, e) {
		var $e = $(e);
		var elementCtId = void 0;

		// Verify that the element being bound has an ID.
		// This ID will need to be altered for each instance of the template
		// that is constructed.
		if (typeof (elementCtId = $e.attr('data-ct-id')) === 'undefined') {
			$e.attr('data-ct-id', elementCtId = uniqId());
		}

		// determine which JQuery method to use to interact with the
		// target element's value.
		var method = void 0;
		if ($e.is(':checkbox,:radio')) {
			method = function method(e) {
				for (var _len = arguments.length, x = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					x[_key - 1] = arguments[_key];
				}

				return e.prop.apply(e, ['checked'].concat(x));
			};
		} else if ($e.is(':input')) {
			method = function method(e) {
				for (var _len2 = arguments.length, x = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
					x[_key2 - 1] = arguments[_key2];
				}

				return e.val.apply(e, x);
			};
		} else {
			method = function method(e) {
				for (var _len3 = arguments.length, x = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
					x[_key3 - 1] = arguments[_key3];
				}

				return e.text.apply(e, x);
			};
		}

		methods[elementCtId] = method;

		// Iterate over data-ct-bind values within the template and construct
		// an model-to-view and view-to-model mapping for data so it can be
		// moved either direction as needed.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = $e.attr('data-ct-bind').match(/([<>=]?\w+)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var bind = _step.value;

				var _bind$match = bind.match(bindingExpr);

				var _bind$match2 = _slicedToArray(_bind$match, 3);

				var bindString = _bind$match2[0];
				var direction = _bind$match2[1];
				var attribute = _bind$match2[2];


				direction = direction || '=';

				// model to view
				if (direction === '=' || direction === '<') {
					m2v[attribute] = m2v[attribute] || [];
					m2v[attribute].push(elementCtId);
				}

				// view to model
				if (direction === '=' || direction === '>') {
					v2m[elementCtId] = v2m[elementCtId] || [];
					v2m[elementCtId].push(attribute);
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	});

	var create = function create(model) {
		return new CTTemplateInstance($template, bindings, model, options);
	};

	// expose processed data for outside systems.
	create.template = template;
	create.bindings = bindings;

	// return a function when called, creates a new TemplateInstance.
	return create;
}

var CTTemplateInstance = function () {
	function CTTemplateInstance($template, bindings, model, options) {
		var _this = this;

		_classCallCheck(this, CTTemplateInstance);

		this.$el = $template.clone();

		this.bindings = bindings;
		this.invalidation = options.invalidation;
		this.modification = options.modification;
		this.hasFocus = options.hasFocus;
		this.entryHeight = options.entryHeight;

		this.$el.on('change', function (e) {

			// apply change to model
			var v2m = _this.bindings.v2m;
			var $target = $(e.target);
			var ctId = $target.attr('data-ct-id');
			var value = _this.bindings.methods[ctId]($target);
			var changes = {};

			if (v2m.hasOwnProperty(ctId)) {
				_.each(v2m[ctId], function (attrib) {
					changes[attrib] = value;
				});
				_this.model.set(changes);
			}
		});

		// find auto-fill elements once and cache references to them.
		var elementMap = new Map(); //{};
		_.each(_.pairs(this.bindings.m2v), function (_ref) {
			var _ref2 = _slicedToArray(_ref, 2);

			var attrib = _ref2[0];
			var ctIds = _ref2[1];

			_.each(ctIds, function (ctId) {
				if (!elementMap.hasOwnProperty(ctId)) {
					elementMap.set(ctId, _this.$el.find('[data-ct-id="' + ctId + '"]'));
				}
			});
		});

		this.elementMap = elementMap;
	}

	_createClass(CTTemplateInstance, [{
		key: 'applyValidationStates',
		value: function applyValidationStates(changes) {
			var _this2 = this;

			var bindings = this.bindings,
			    m2v = bindings.m2v,
			    invalidations = this.invalidation(this.model.cid),
			    i;

			// Prefer to use changes since we can optimize changes.
			if (changes) {
				for (i = 0; i < changes.length; i++) {
					var field = changes[i];
					var message = invalidations && invalidations[changes[i]] || undefined;

					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = m2v[field][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var elementId = _step2.value;

							var $element = this.elementMap.get(elementId);

							$element.attr('validation-msg', message).toggleClass('ui-state-error', typeof message === 'string');
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}
				return; // All done!
			}

			// Do it the dumb way, wipe all invalid states.
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this.elementMap[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _step3$value = _slicedToArray(_step3.value, 2);

					var _elementId2 = _step3$value[0];
					var _$element2 = _step3$value[1];

					_$element2.removeClass('ui-state-error');
				}

				// Apply invalidation markers and messages.
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			if (invalidations) {
				_.each(_.pairs(invalidations), function (_ref3) {
					var _ref4 = _slicedToArray(_ref3, 2);

					var field = _ref4[0];
					var errorMsg = _ref4[1];
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = m2v[field][Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var _elementId = _step4.value;

							var _$element = _this2.elementMap.get(_elementId);

							if (_$element.is(':enabled')) {
								_$element.attr('validation-msg', errorMsg).addClass('ui-state-error');
							}
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				});
			}
		}
	}, {
		key: 'applyModificationStates',
		value: function applyModificationStates(changes) {
			var bindings = this.bindings,
			    m2v = bindings.m2v,
			    modifications = this.modification(this.model.cid),
			    i;

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = this.elementMap[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _step5$value = _slicedToArray(_step5.value, 2);

					var _elementId3 = _step5$value[0];
					var _$element3 = _step5$value[1];

					_$element3.removeClass('ui-state-modified');
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			if (modifications) {
				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;

				try {
					for (var _iterator6 = modifications[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						var field = _step6.value;
						var _iteratorNormalCompletion7 = true;
						var _didIteratorError7 = false;
						var _iteratorError7 = undefined;

						try {
							for (var _iterator7 = m2v[field][Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
								var elementId = _step7.value;

								var $element = this.elementMap.get(elementId);
								$element.addClass('ui-state-modified');
							}
						} catch (err) {
							_didIteratorError7 = true;
							_iteratorError7 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion7 && _iterator7.return) {
									_iterator7.return();
								}
							} finally {
								if (_didIteratorError7) {
									throw _iteratorError7;
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 && _iterator6.return) {
							_iterator6.return();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}
			}
		}
	}, {
		key: 'setModel',
		value: function setModel(model, extra) {
			var _this3 = this;

			if (this.model) {
				this.stopListening();
			}

			this.model = model;
			this.$el.attr('data-model-cid', model.cid) // Easily scan DOM for specific model CID
			.data('ct-template', this) // Allows us to find this object through the DOM
			.toggleClass('ct-focus', this.hasFocus(model.cid)) //
			.css('height', this.entryHeight() - 1 + 'px') // +1 so entries overlap by 1 pixel
			;

			this.listenTo(model, 'change', function (change) {
				_this3.autofill(null, extra);
			});

			_.defer(function () {
				return _this3.applyValidationStates();
			});
			this.applyModificationStates();

			this.autofill(null, extra);
		}
	}, {
		key: 'autofill',
		value: function autofill(attrs, extra) {
			var _this4 = this;

			// model attributes list to autofill
			attrs = attrs || _.keys(this.bindings.m2v);
			var data = _.extend(this.model.toJSON(), extra);
			var m2v = this.bindings.m2v;
			var methods = this.bindings.methods;

			_.each(attrs, function (attr) {
				_.each(m2v[attr], function (name) {

					var method = methods[name];
					method(_this4.elementMap.get(name), data[attr]);
				});
			});
		}
	}, {
		key: 'focusField',
		value: function focusField(fieldname) {
			var fields = this.bindings.m2v[fieldname];

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = fields[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var field = _step8.value;

					var $elem = this.elementMap.get(field);
					if ($elem && $elem.is(':visible')) {
						$elem.focus();
						return;
					}
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}
		}
	}]);

	return CTTemplateInstance;
}();

Object.assign(CTTemplateInstance.prototype, Backbone.Events);
module.exports = exports['default'];

},{"./jquery-selectors":8}]},{},[2])(2)
});


//# sourceMappingURL=configtable2.js.map
